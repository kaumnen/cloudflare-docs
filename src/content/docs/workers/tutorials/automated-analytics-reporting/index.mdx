---
updated: 2024-10-31
difficulty: Beginner
content_type: üìù Tutorial
pcx_content_type: tutorial
title: Automated Analytics Reporting with Cloudflare Workers and Email Routing
products:
  - Workers
  - Email Routing
languages:
  - JavaScript
---

import { Render, PackageManagers } from "~/components";
import { TabItem, Tabs } from "~/components";

In this tutorial, you will create a [Cloudflare Worker](https://workers.cloudflare.com/) that fetches analytics data about your account from Cloudflare's [GraphQL Analytics API](https://developers.cloudflare.com/analytics/graphql-api/). You will be able to view the account analytics data in your browser and receive a scheduled email report.

You will learn:

1. How to create a Worker using the `c3` CLI.
2. How to fetch analytics data from Cloudflare's GraphQL Analytics API.
3. How to send an email with a Worker.
4. How to schedule the Worker to run at a specific time.
5. How to store secrets and environment variables in your Worker.
6. How to test the Worker locally.
7. How to deploy the Worker to Cloudflare's edge network.

## Prerequisites

Before you start, make sure you:

<Render file="prereqs" product="workers" />

3. [Add a domain](https://developers.cloudflare.com/fundamentals/setup/manage-domains/add-site/) to your Cloudflare account.
4. [Enable Email Routing](https://developers.cloudflare.com/email-routing/get-started/enable-email-routing/) for your domain.
5. Create Cloudflare's [Analytics API token](https://developers.cloudflare.com/analytics/graphql-api/getting-started/authentication/api-token-auth/).

## Create a Worker

While you can create a Worker using the Cloudflare dashboard, creating a Worker using the `c3` CLI is recommended as it provides a more streamlined development experience and allows you to test your Worker locally.

First, use the `c3` CLI to create a new Cloudflare Workers project.

<PackageManagers
	type="create"
	pkg="cloudflare@latest"
	args={"account-analytics"}
/>

In this tutorial, we will name our Worker `account-analytics`.

<Render
	file="c3-post-run-steps"
	product="workers"
	params={{
		category: "hello-world",
		type: "Hello World Worker",
		lang: "JavaScript",
	}}
/>

Now, the worker is set up. Move into that project directory.

```sh
cd account-analytics
```

Before we continue with the tutorial, let's install [`mimetext`](https://www.npmjs.com/package/mimetext) package.

<Tabs> <TabItem label="pnpm">

```sh
pnpm install mimetext
```

</TabItem> <TabItem label="npm">

```sh
npm install mimetext
```

</TabItem> <TabItem label="yarn">

```sh
yarn add mimetext
```

</TabItem> </Tabs>

## Update wrangler.toml

[`wrangler.toml`](https://developers.cloudflare.com/workers/wrangler/configuration/) is the configuration file for your Worker. It was created when you ran `c3` CLI. Open `wrangler.toml` in your code editor and update it with the following configuration:

```toml
name = "account-analytics"
main = "src/index.js"

# Set to the current date
compatibility_date = "<>"
compatibility_flags = ["nodejs_compat"]

# Set destination_address to the email address where you want to receive the report
send_email = [
    {name = "ANALYTICS_EMAIL", destination_address = "<>"}
]

# Schedule the Worker to run every day at 10:00 AM
[triggers]
crons = ["0 10 * * *"]

# Enable observability to view Worker logs
[observability]
enabled = true

[vars]
# This value shows the name of the sender in the email
SENDER_NAME = "Cloudflare Analytics Worker"

# This email address will be used as the sender of the email
SENDER_EMAIL = "<>"

# This email address will be used as the recipient of the email
RECIPIENT_EMAIL = "<>"

# This value will be used as the subject of the email
EMAIL_SUBJECT = "Cloudflare Analytics Report"
```

Before you continue, update the following:

1. `compatibility_date` with the current date.
2. `destination_address` with the email address where you want to receive the analytics report.
3. `[VARS]` with the environment variable values you want to use in your Worker.

:::note[IMPORTANT]
`destination_address` and `RECIPIENT_EMAIL` **must** contain [Email Routing verified email](https://developers.cloudflare.com/email-routing/get-started/enable-email-routing/) address.

`SENDER_EMAIL` **must** be address on a domain that:

1. Is added to your Cloudflare domain
2. Has Email Routing enabled.
   :::

## Update the Worker code

While you are in your project directory, open `src/index.js` in your code editor and update it with the following code:

```js
import { EmailMessage } from "cloudflare:email";
import { createMimeMessage } from "mimetext";

export default {
	async fetch(request, env, ctx) {
		try {
			const analyticsData = await fetchAnalytics(env);
			const formattedContent = formatContent(
				analyticsData.data,
				analyticsData.formattedDate,
			);
			return new Response(formattedContent, {
				headers: { "Content-Type": "text/plain" },
			});
		} catch (error) {
			console.error("Error:", error);
			return new Response(`Error: ${error.message}`, {
				status: 500,
				headers: { "Content-Type": "text/plain" },
			});
		}
	},

	async scheduled(event, env, ctx) {
		try {
			const analyticsData = await fetchAnalytics(env);
			const formattedContent = formatContent(
				analyticsData.data,
				analyticsData.formattedDate,
			);
			await sendEmail(env, formattedContent);
			console.log("Analytics email sent successfully");
		} catch (error) {
			console.error("Failed to send analytics email:", error);
		}
	},
};

async function fetchAnalytics(env) {
	const yesterday = new Date();
	yesterday.setDate(yesterday.getDate() - 1);
	const dateString = yesterday.toISOString().split("T")[0];
	const formattedDate = yesterday.toLocaleDateString("en-US", {
		weekday: "long",
		year: "numeric",
		month: "long",
		day: "numeric",
	});

	const response = await fetch(`https://api.cloudflare.com/client/v4/graphql`, {
		method: "POST",
		headers: {
			Authorization: `Bearer ${env.CF_API_TOKEN}`,
			"Content-Type": "application/json",
		},
		body: JSON.stringify({
			query: `
                query GetAnalytics($accountTag: String!, $date: String!) {
                    viewer {
                        accounts(filter: { accountTag: $accountTag }) {
                            httpRequests1dGroups(limit: 1, filter: { date: $date }) {
                                sum {
                                    requests
                                    pageViews
                                    bytes
                                    encryptedRequests
                                    encryptedBytes
                                    cachedRequests
                                    cachedBytes
                                    threats
                                    browserMap {
                                        pageViews
                                        uaBrowserFamily
                                    }
                                    responseStatusMap {
                                        requests
                                        edgeResponseStatus
                                    }
                                    clientHTTPVersionMap {
                                        requests
                                        clientHTTPProtocol
                                    }
                                }
                            }
                        }
                    }
                }
            `,
			variables: {
				accountTag: env.CF_ACCOUNT_ID,
				date: dateString,
			},
		}),
	});

	const data = await response.json();
	if (data.errors) {
		throw new Error(`GraphQL Error: ${JSON.stringify(data.errors)}`);
	}

	return { data, formattedDate };
}

function formatContent(analyticsData, formattedDate) {
	const stats =
		analyticsData.data.viewer.accounts[0].httpRequests1dGroups[0].sum;

	const formatBytes = (bytes) => {
		if (bytes === 0) return "0 Bytes";
		const k = 1024;
		const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
		const i = Math.floor(Math.log(bytes) / Math.log(k));
		return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
	};

	const browserData = stats.browserMap
		.sort((a, b) => b.pageViews - a.pageViews)
		.map((b) => `    ${b.uaBrowserFamily}: ${b.pageViews} views`)
		.join("\n");

	const statusData = stats.responseStatusMap
		.sort((a, b) => b.requests - a.requests)
		.map((s) => `    ${s.edgeResponseStatus}: ${s.requests} requests`)
		.join("\n");

	const httpVersionData = stats.clientHTTPVersionMap
		.sort((a, b) => b.requests - a.requests)
		.map((h) => `    ${h.clientHTTPProtocol}: ${h.requests} requests`)
		.join("\n");

	return `
CLOUDFLARE ANALYTICS REPORT
==========================
Generated for: ${formattedDate}

TRAFFIC OVERVIEW
---------------
    Total Requests: ${stats.requests.toLocaleString()}
    Page Views: ${stats.pageViews.toLocaleString()}
    Security Threats Blocked: ${stats.threats.toLocaleString()}

BANDWIDTH
---------
    Total Bandwidth: ${formatBytes(stats.bytes)}
    Encrypted Bandwidth: ${formatBytes(stats.encryptedBytes)}
    Cached Bandwidth: ${formatBytes(stats.cachedBytes)}

CACHING & ENCRYPTION
-------------------
    Total Requests: ${stats.requests.toLocaleString()}
    Encrypted Requests: ${stats.encryptedRequests.toLocaleString()}
    Cached Requests: ${stats.cachedRequests.toLocaleString()}
    Encryption Rate: ${((stats.encryptedRequests / stats.requests) * 100).toFixed(1)}%
    Cache Rate: ${((stats.cachedRequests / stats.requests) * 100).toFixed(1)}%

BROWSERS
--------
${browserData}

HTTP STATUS CODES
---------------
${statusData}

HTTP VERSIONS
------------
${httpVersionData}
`;
}

async function sendEmail(env, content) {
	const msg = createMimeMessage();

	msg.setSender({
		name: env.SENDER_NAME,
		addr: env.SENDER_EMAIL,
	});

	msg.setRecipient(env.RECIPIENT_EMAIL);
	msg.setSubject(env.EMAIL_SUBJECT);

	msg.addMessage({
		contentType: "text/plain",
		data: content,
	});

	const message = new EmailMessage(
		env.SENDER_EMAIL,
		env.RECIPIENT_EMAIL,
		msg.asRaw(),
	);

	try {
		await env.ANALYTICS_EMAIL.send(message);
	} catch (error) {
		throw new Error(`Failed to send email: ${error.message}`);
	}
}
```

## Test the Worker

Now that you have updated the Worker code, you can test it locally using the `wrangler dev` command. This command starts a local server that runs your Worker code.

Before you run the Worker, you need to add two Worker secrets:

- `CF_API_TOKEN`: Cloudflare GraphQL Analytics API token you created earlier.
- `CF_ACCOUNT_ID`: Your Cloudflare account ID. Can be found in the Cloudflare dashboard under the Workers & Pages Overview tab.

Let's create `.dev.vars` file in the root of your project directory and add the following:

```sh
CF_API_TOKEN=YOUR_CLOUDFLARE_API_TOKEN
CF_ACCOUNT_ID=YOUR_CLOUDFLARE_ACCOUNT_ID
```

Now, run the Worker locally:

```sh
npx wrangler dev --remote
```

Open your browser and visit `http://localhost:8787`. You should see the analytics data displayed in your browser.

## Deploy the Worker and Worker secrets

Once you have tested the Worker locally, you can deploy it to Cloudflare's edge network:

```sh
npx wrangler deploy
```

CLI command will output the URL where your Worker is deployed. Before you can visit this URL in your browser to view the analytics data, you need to add two Worker secrets you already have locally to your deployed Worker:

```sh
npx wrangler secret put <secret>
```

Change `<secret>` with the name of the secret you want to add. Repeat this command for `CF_API_TOKEN` and `CF_ACCOUNT_ID` secrets.

Once you put the secrets, visit the `account-analytics.<YOUR_SUBDOMAIN>.workers.dev` to view the analytics data. You will also receive an email report to the specified recipient email address every day at 10:00 AM.

If you want to disable a public URL for your Worker, you can do so by following these steps:

1. Log in to the [Cloudflare dashboard](https://dash.cloudflare.com).

2. In Account Home, select **Workers & Pages**, and then select `account-analytics` Worker.

3. Go to **Settings** - **Domains & Routes**

4. Click 'Disable' to disable the public `account-analytics.<YOUR_SUBDOMAIN>.workers.dev` URL.

You have successfully created, tested and deployed a Worker that fetches analytics data from Cloudflare‚Äôs GraphQL Analytics API and sends an email report via Email Routing.

## Related resources

To build more with Workers, refer to [Tutorials](/workers/tutorials/).

If you have any questions, need assistance, or would like to share your project, join the Cloudflare Developer community on [Discord](https://discord.cloudflare.com) to connect with other developers and the Cloudflare team.
